# Обзор кодовой базы проекта DuoNiche Backend

## 1. Общее назначение проекта

DuoNiche Backend — это бэкенд-сервис, построенный на базе фреймворка FastAPI. Его основная задача — обеспечивать логику для Telegram-бота по изучению языков. Сервис использует Large Language Models (LLMs) для генерации учебных упражнений и автоматической проверки ответов пользователей. Он также управляет прогрессом пользователей, обрабатывает платежи (через Telegram Stars) и планирует уведомления.

## 2. Структура проекта
Проект имеет следующую основную структуру директорий:
```text
.
├── .github/              # Конфигурации GitHub Actions (CI/CD)
│ └── workflows/
│       └── deploy.yml    # Workflow деплоя на прод
├── alembic/              # Скрипты миграций базы данных (SQLAlchemy Alembic)
│   ├── versions/         # Файлы конкретных версий миграций
│   ├── env.py            # Среда выполнения миграций
│   └── ...
├── app/                  # Основной пакет приложения
│   ├── api/              # Определение HTTP API (FastAPI)
│   │   ├── schemas/      # Pydantic схемы для запросов/ответов API
│   │   └── v1/           # Версионирование API (v1)
│   │       ├── endpoints/ # Обработчики конкретных эндпоинтов
│   │       └── api.py     # Роутер для API v1
│   ├── core/             # Основная бизнес-логика и доменные сущности
│   │   ├── entities/     # Pydantic модели доменных сущностей
│   │   ├── interfaces/   # Абстрактные базовые классы (интерфейсы)
│   │   ├── repositories/ # Абстрактные базовые классы (интерфейсы) для репозиториев
│   │   ├── services/     # Сервисы бизнес-логики
│   │   └── value_objects/ # Value Objects
│   ├── db/               # Взаимодействие с базой данных
│   │   ├── models/       # SQLAlchemy ORM модели
│   │   ├── repositories/ # Реализации репозиториев на SQLAlchemy
│   │   └── db.py         # Настройка движка БД и сессий
│   ├── infrastructure/   # Внешние инфраструктурные зависимости (Redis)
│   │   └── redis_client.py
│   ├── llm/              # Логика взаимодействия с LLM
│   │   ├── generators/   # Генераторы упражнений на базе LLM
│   │   ├── interfaces/   # Интерфейсы генераторов/валидаторов LLM
│   │   ├── validators/   # Валидаторы ответов на базе LLM
│   │   ├── factories.py  # Фабрики для создания генераторов/валидаторов
│   │   ├── llm_base.py   # Базовый класс для LLM сервисов
│   │   ├── llm_service.py # Сервис для генерации и валидации через LLM
│   │   └── llm_translator.py # Сервис для перевода через LLM
│   ├── services/         # Внешние сервисы (Google Translate, Notification Producer)
│   │   ├── choose_accent_generator.py # Генератор упражнений на ударения
│   │   └── notification_producer.py # Сервис для постановки задач уведомлений
│   ├── utils/            # Вспомогательные утилиты
│   ├── workers/          # Фоновые воркеры
│   │   ├── exercise_stock_refill.py # Пополнение запаса упражнений
│   │   ├── metrics_updater.py # Обновление пользовательских метрик
│   │   └── notification_scheduler.py # Планирование уведомлений
│   ├── celery_producer.py # Настройка Celery клиента
│   ├── config.py         # Настройки приложения
│   ├── logging_config.py # Настройка логирования
│   ├── main.py           # Точка входа FastAPI приложения
│   ├── metrics.py        # Определение метрик Prometheus
│   └── sentry_sdk.py     # Настройка Sentry
├── infra/                # Конфигурации инфраструктуры (Docker Compose, Nginx)
├── tests/                # Тесты
│   ├── api/              # Тесты API эндпоинтов
│   ├── core/             # Тесты бизнес-логики
│   ├── db/               # Тесты моделей и репозиториев БД
│   ├── integration/      # Интеграционные тесты
│   ├── llm/              # Тесты LLM модулей
│   ├── metrics/          # Тесты метрик
│   └── notifications/    # Тесты уведомлений
├── Dockerfile            # Dockerfile для сборки образа приложения
├── entrypoint.sh         # Скрипт точки входа Docker контейнера
├── pyproject.toml        # Конфигурация проекта (uv, ruff, mypy, pytest)
└── README.md             # Документация проекта
```
## 3. Ключевые модули и их функционал

### `app/main.py`
- **Расположение:** `app/main.py`
- **Назначение:** Точка входа FastAPI приложения. Определяет `lifespan` для инициализации и корректного завершения ресурсов (БД, Redis, HTTPX клиент, LLM сервисы, кеш, продюсер уведомлений). Запускает фоновые воркеры при старте. Подключает API роутеры (`app.api.v1.api.api_router`) и метрики Prometheus.

### `app/config.py`
- **Расположение:** `app/config.py`
- **Назначение:** Централизованное управление всеми настройками приложения с использованием `pydantic-settings`. Загружает конфигурацию из переменных окружения (по умолчанию из `.env` файла). Содержит настройки для БД, Redis, OpenAI, Google API, параметров сессий упражнений, уведомлений и т.д.

### `app/api/`
- **Назначение:** Определяет структуру и логику HTTP API.
  - **`app/api/schemas/`**: Содержит Pydantic модели для валидации и сериализации данных запросов и ответов API (например, `UserCreate`, `ExerciseSchema`, `ValidationResultSchema`).
  - **`app/api/v1/endpoints/`**: Содержит модули с обработчиками (роутерами FastAPI) для конкретных API эндпоинтов. Например:
    - `exercises.py`: Валидация ответов на упражнения.
    - `next_action.py`: Получение следующего действия/упражнения для пользователя.
    - `notifications.py`: Эндпоинт для проверки релевантности уведомлений (реализация неполная).
    - `users.py`: Создание/обновление пользователей, обработка блокировок, обновление настроек уведомлений, обработка платежей.
  - **`app/api/v1/api.py`**: Собирает все роутеры из `endpoints` в один `APIRouter` для версии v1 API.
  - **`app/api/dependencies.py`**: Определяет зависимости FastAPI (Dependency Injection) для предоставления экземпляров сервисов и репозиториев в обработчики эндпоинтов (например, `get_user_service`, `get_exercise_service`).
  - **`app/api/errors.py`**: Определяет кастомные HTTP исключения (например, `NotFoundError`).

### `app/core/`
- **Назначение:** Содержит основную бизнес-логику и доменные сущности приложения, стремясь к независимости от конкретных фреймворков и внешних сервисов.
  - **`app/core/entities/`**: Pydantic модели, представляющие основные доменные сущности (например, `User`, `Exercise`, `UserBotProfile`, `Payment`).
  - **`app/core/interfaces/`**: Абстрактные базовые классы (интерфейсы), определяющие контракты для внешних сервисов (например, `LLMProvider`, `TranslateProvider`).
  - **`app/core/repositories/`**: Абстрактные интерфейсы репозиториев, определяющие методы для взаимодействия с хранилищем данных (например, `UserRepository`, `ExerciseRepository`).
  - **`app/core/services/`**: Классы-сервисы, инкапсулирующие бизнес-логику. Они координируют работу репозиториев и других сервисов.
    - `user.py`: Управление пользователями (создание, получение, обновление).
    - `user_bot_profile.py`: Управление профилями пользователей для конкретных ботов (языков).
    - `exercise.py`: Сервис для получения упражнений и валидации ответов. Использует `ExerciseGetter` и `AttemptValidator`.
    - `exercise_getter.py`: Логика выбора следующего упражнения (новое, для повторения).
    - `attempt_validator.py`: Логика валидации попытки пользователя, включая кеширование и взаимодействие с LLM.
    - `user_progress.py`: Определяет следующее действие для пользователя в боте (новое упражнение, сообщение о лимите, предложение оплаты).
    - `payment.py`: Обработка информации о платежах, формирование данных для инвойсов.
    - `async_task_cache.py`: Реализация кеша для асинхronных задач с использованием Redis.
  - **`app/core/value_objects/`**: Определяет Value Objects (например, `Answer`, `ExerciseData`) с их специфической логикой и фабриками для создания.
  - **`app/core/enums.py`**: Перечисления, используемые в доменной логике (например, `ExerciseType`, `UserAction`, `LanguageLevel`).
  - **`app/core/exercise_templates.py`**: Маппинг типов упражнений на UI шаблоны для Telegram-бота.
  - **`app/core/texts.py`**: Централизованное хранение и получение текстов сообщений и переводов для различных языков.

### `app/db/`
- **Назначение:** Уровень доступа к данным, реализующий взаимодействие с базой данных PostgreSQL.
  - **`app/db/models/`**: Определяет SQLAlchemy ORM модели (например, `User`, `Exercise`, `DBUserBotProfile`), которые отображают доменные сущности на таблицы базы данных.
  - **`app/db/repositories/`**: Реализует интерфейсы репозиториев из `app/core/repositories/` с использованием SQLAlchemy для выполнения CRUD-операций (например, `SQLAlchemyUserRepository`, `SQLAlchemyExerciseRepository`).
  - **`app/db/db.py`**: Настройка асинхронного движка SQLAlchemy (`create_async_engine`) и фабрики сессий (`async_sessionmaker`). Содержит функции для инициализации (`init_db`) и удаления (`drop_models`) таблиц.

### `app/llm/`
- **Назначение:** Интеграция с Large Language Models (LLMs), в основном через библиотеку LangChain для взаимодействия с OpenAI API.
  - **`app/llm/llm_base.py`**: Базовый класс (`BaseLLMService`) для взаимодействия с LLM, управляет созданием цепочек (chains) и выполнением запросов.
  - **`app/llm/llm_service.py`**: Основной сервис (`LLMService`), реализующий интерфейс `LLMProvider`. Использует фабрики для создания специфичных генераторов и валидаторов упражнений. Также включает интеграцию с `ExerciseQualityAssessor`.
  - **`app/llm/llm_translator.py`**: Сервис (`LLMTranslator`), реализующий интерфейс `TranslateProvider` для перевода фидбека с использованием LLM.
  - **`app/llm/generators/`**: Модули с классами-генераторами для различных типов упражнений (`FillInTheBlankGenerator`, `ChooseSentenceGenerator`). Содержат логику формирования промптов и парсинга ответов LLM.
    - `prompt_templates.py`: Шаблоны промптов для генерации упражнений.
  - **`app/llm/validators/`**: Модули с классами-валидаторами для различных типов упражнений (`FillInTheBlankValidator`, `ChooseSentenceValidator`). Содержат логику формирования промптов для валидации и парсинга ответов LLM.
    - `prompt_templates.py`: Шаблоны промптов для валидации ответов.
  - **`app/llm/factories.py`**: Фабричные классы (`ExerciseGeneratorFactory`, `ExerciseValidatorFactory`) для создания экземпляров генераторов и валидаторов в зависимости от типа упражнения.
  - **`app/llm/quality_assessor.py`**: Класс (`ExerciseQualityAssessor`) для оценки качества сгенерированных упражнений (реализация неполная).

### `app/services/` (внешние/специфические сервисы)
- **Назначение:** Содержит интеграции с внешними сервисами или специфическую логику, которая не является частью основного домена `core` или `llm`.
  - **`app/services/choose_accent_generator.py`**: Генератор упражнений на расстановку ударений, который использует скраппинг с внешнего сайта (`rechnik.chitanka.info`), а не LLM.
  - **`app/services/google_translator.py`**: Интеграция с Google Translate API (реализация неполная, `translate_feedback` не реализован).
  - **`app/services/notification_producer.py`**: Сервис (`NotificationProducerService`) для создания и постановки задач уведомлений в очередь Celery. Формирует данные для уведомлений (`NotificationTaskData`).

### `app/workers/`
- **Назначение:** Содержит фоновые задачи (воркеры), которые запускаются при старте FastAPI приложения и выполняются в отдельных асинхронных циклах.
  - **`app/workers/exercise_stock_refill.py`**: Периодически проверяет количество неиспользованных упражнений в БД и генерирует новые с помощью `LLMService` или `ChooseAccentGenerator`, если запас мал.
  - **`app/workers/metrics_updater.py`**: Периодически собирает и обновляет пользовательские метрики Prometheus (например, количество активных сессий, длительность сессий).
  - **`app/workers/notification_scheduler.py`**: Периодически проверяет профили пользователей и планирует отправку уведомлений (например, о доступности новой сессии или о долгом перерыве) через `NotificationProducerService`.

### `app/celery_producer.py`
- **Назначение:** Настройка Celery клиента (`notifier_celery_producer`) для отправки задач в очередь (используется `NotificationProducerService`). Предполагается, что задачи из этой очереди обрабатываются отдельным сервисом-консьюмером (Notifier).

### `alembic/`
- **Назначение:** Управление миграциями схемы базы данных с использованием Alembic. Позволяет версионировать изменения в структуре БД и применять/откатывать их.
  - `versions/`: Содержит файлы с конкретными версиями миграций.
  - `env.py`: Конфигурационный файл для Alembic, настраивает подключение к БД и указывает на модели SQLAlchemy.

### `infra/`
- **Назначение:** Конфигурации для развертывания приложения с использованием Docker и Docker Compose. Включает настройки для базы данных (PostgreSQL), кэша (Redis), самого бэкенда, веб-сервера (Nginx) и системы мониторинга (Prometheus).
  - `dev/`: Конфигурации для локальной разработки.
  - `nginx/`: Шаблон конфигурации Nginx.
  - `docker-compose.*.yml`: Файлы Docker Compose для различных окружений.
  - `prometheus.yml`: Конфигурация Prometheus.

### `tests/`
- **Назначение:** Содержит автоматические тесты для различных частей приложения, используя pytest. Включает юнит-тесты, интеграционные тесты и тесты API.
  - `conftest.py`: Определяет общие фикстуры для тестов (например, асинхронный клиент FastAPI, сессии БД, моки сервисов).

## 4. Основные сценарии использования (Workflows)

1.  **Регистрация/Обновление пользователя:**
    - Telegram-бот отправляет данные пользователя (telegram_id, username, язык и т.д.) на эндпоинт `PUT /api/v1/users/`.
    - `UserService` и `UserBotProfileService` создают или обновляют запись о пользователе и его профиль для конкретного бота (языка).

2.  **Получение следующего действия/упражнения:**
    - Telegram-бот запрашивает `GET /api/v1/users/{user_id}/bots/{bot_id}/next-action/`.
    - `UserProgressService` анализирует состояние пользователя (прогресс, лимиты, время последнего упражнения) и определяет следующее действие:
        - Параметры (Topic, LanguageLevel, ExerciseType) следующего упражнения определяются в соответствующих enum.
        - Если доступно новое упражнение: `ExerciseService` (через `ExerciseGetter`) получает его из БД. Если точно подходящего нового упражнения нет, подбирается частично подходящее новое, если такого тоже нет, выбирается из пройденный. Возвращается `UserAction.new_exercise` с данными упражнения.
        - Если достигнут лимит упражнений в сете: Возвращается `UserAction.praise_and_next_set` с сообщением.
        - Если достигнут лимит упражнений в сессии: Возвращается `UserAction.congratulations_and_wait` с сообщением, временем до следующей сессии и информацией для оплаты (`TelegramPayment`).
        - Если сессия заморожена: Возвращается `UserAction.limit_reached` с сообщением, временем до следующей сессии и информацией для оплаты (`TelegramPayment`).
        - В случае ошибки: Возвращается `UserAction.error`.

3.  **Ответ на упражнение и валидация:**
    - Telegram-бот отправляет ответ пользователя на эндпоинт `POST /api/v1/exercises/{exercise_id}/validate/` (или легаси для миниапп `POST /api/v1/exercises/validate/`).
    - `ExerciseService` (через `AttemptValidator`):
        - Проверяет кеш (`AsyncTaskCache`) на наличие ранее валидированного ответа для этого упражнения и ответа пользователя.
        - Если в кеше нет, проверяет БД (`exercise_answers`) на наличие ранее сохраненного ответа.
        - Если ответ не найден или фидбек на другом языке, использует `LLMService` для валидации ответа через LLM или `LLMTranslator` для перевода существующего фидбека.
        - Результат валидации (правильность, фидбек) сохраняется в БД (`exercise_answers`) и кешируется.
        - Создается запись о попытке пользователя (`exercise_attempts`).
        - Возвращается результат валидации (`ValidationResultSchema`).

4.  **Обработка платежа (Telegram Stars) для разблокировки сессии:**
    - После успешной оплаты в Telegram, бот отправляет данные платежа на эндпоинт `POST /api/v1/users/{user_id}/bots/{bot_id}/payments/unlock-session`.
    - `PaymentService` записывает информацию о платеже в таблицу `payments`, обрабатывая возможные дубликаты.
    - `UserBotProfileService` сбрасывает счетчики упражнений и время заморозки для соответствующего `user_bot_profile`, фактически начиная новую сессию для пользователя.

5.  **Фоновая генерация упражнений:**
    - Воркер `exercise_stock_refill_loop` периодически запускает `exercise_stock_refill`.
    - `SQLAlchemyExerciseRepository.count_untouched_exercises()` проверяет количество неиспользованных упражнений.
    - Если количество меньше порогового значения (`MIN_EXERCISE_COUNT_TO_GENERATE_NEW`), запускаются задачи `generate_and_save_exercise` для пополнения запаса. Эти задачи используют `LLMService` или `ChooseAccentGenerator`.

6.  **Планирование и отправка уведомлений:**
    - Воркер `notification_scheduler_loop` периодически запускает `NotificationScheduler.run_check_cycle()`.
    - `NotificationScheduler` запрашивает у `SQLAlchemyUserBotProfileRepository` профили пользователей, которые соответствуют критериям для уведомлений (например, сессия разморозилась, пользователь давно не занимался).
    - Для каждого такого профиля, `NotificationProducerService` создает задачу (`NotificationTaskData`) с текстом уведомления и ставит ее в очередь Celery (`notification_tasks_default`).
    - Предполагается, что отдельный сервис-консьюмер (Notifier, не часть этого репозитория) забирает задачи из очереди и отправляет сообщения пользователям через Telegram API.

## 5. Зависимости и интеграции

- **Основной фреймворк:** FastAPI
- **Асинхронная работа:** asyncio
- **База данных:** PostgreSQL (используется с асинхронным драйвером `asyncpg` и ORM `SQLAlchemy 2.0`)
- **Миграции БД:** Alembic
- **Кэширование/Очереди:** Redis (используется для кеша асинхронных задач в бэкенде и как брокер для Celery)
- **LLM (Large Language Models):** OpenAI API (через библиотеку `LangChain`)
- **Переводы:** LLM (через `LangChain`) и, возможно, Google Translate API (частично реализовано в `app/services/google_translator.py`)
- **Очередь задач:** Celery (используется как продюсер для отправки задач в отдельный сервис Notifier)
- **HTTP-клиент:** `httpx` (для исходящих асинхронных запросов, например, к API LLM или внешним сайтам для скраппинга)
- **Метрики:** Prometheus (через `prometheus-client` и `prometheus-fastapi-instrumentator`)
- **Логирование ошибок:** Sentry (через `sentry-sdk`)
- **Конфигурация:** `pydantic-settings` (для загрузки настроек из переменных окружения и `.env` файлов)
- **Скраппинг:** `lxml` (используется в `app/services/choose_accent_generator.py`)
- **Информация о языках:** `pycountry` (для конвертации кодов языков)
- **CI/CD:** GitHub Actions (для сборки Docker-образа и деплоя)
- **Управление зависимостями и инструментами разработки:** `uv` (для управления зависимостями), `pyproject.toml` (конфигурация `ruff` для линтинга и форматирования, `mypy` для статической типизации, `pytest` для тестирования)
- **Инструменты для разработки:** `pre-commit` (для автоматического применения хуков перед коммитом)

---